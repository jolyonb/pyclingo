from __future__ import annotations

import time
from collections import defaultdict
from datetime import datetime
from typing import Generator

import clingo

from pyclingo.predicate import Predicate
from pyclingo.program_elements import BlankLine, Comment, ProgramElement, Rule
from pyclingo.term import Term
from pyclingo.value import Constant, StringConstant, SymbolicConstant


class ASPProgram:
    """
    Represents a complete ASP program.

    This class manages a collection of rules, comments, and other elements
    that make up an ASP program, and provides methods to build and render
    the program.
    """

    solved: bool = False
    satisfiable: bool | None = None
    exhausted: bool | None = None
    model_count: int | None = None
    statistics: dict[str, int] | None = None

    def __init__(self) -> None:
        """Initialize an empty ASP program."""
        self._elements: list[ProgramElement] = []
        self._symbolic_constants: dict[str, int | str] = {}

    def fact(self, *predicates: Predicate) -> None:
        """Add one or more unconditional facts to the program."""
        assert all(isinstance(predicate, Predicate) for predicate in predicates)
        for predicate in predicates:
            self._elements.append(Rule(head=predicate))

    def when(self, conditions: Term | list[Term], let: Term) -> None:
        """Create a clingo rule which sets the let term when all conditions are satisfied."""
        condition_list = conditions if isinstance(conditions, list) else [conditions]
        assert all(isinstance(condition, Term) for condition in condition_list)
        assert isinstance(let, Term)
        self._elements.append(Rule(head=let, body=condition_list))

    def forbid(self, *conditions: Term) -> None:
        """Creates a clingo constraint which forbids the specified combination of conditions."""
        assert all(isinstance(condition, Term) for condition in conditions)
        self._elements.append(Rule(body=list(conditions)))

    def comment(self, text: str) -> None:
        """
        Add a comment to the program.

        Args:
            text: The comment text.
        """
        self._elements.append(Comment(text))

    def blank_line(self) -> None:
        """Add a blank line to the program for formatting."""
        self._elements.append(BlankLine())

    def section(self, title: str) -> None:
        """
        Add a section header to the program.

        Args:
            title: The section title.
        """
        self.blank_line()
        self.comment(title)

    def register_symbolic_constant(
        self, name: str, value: int | str
    ) -> SymbolicConstant:
        """
        Register a symbolic constant with the program.

        Args:
            name: The name of the constant.
            value: The value of the constant (integer or string).

        Raises:
            ValueError: If the name is invalid or already registered.
            TypeError: If the value is not an integer or string.
        """
        # Validate name
        assert isinstance(name, str)
        if not name or not name[0].islower():
            raise ValueError(
                f"Constant name must start with a lowercase letter: {name}"
            )

        if not all(c.isalnum() or c == "_" for c in name):
            raise ValueError(
                f"Constant name can only contain letters, digits, and underscores: {name}"
            )

        # Check for duplicate registration
        if name in self._symbolic_constants:
            raise ValueError(f"Symbolic constant '{name}' is already registered")

        # Validate value type
        if not isinstance(value, (int, str)):
            raise TypeError(
                f"Constant value must be an integer or string, got {type(value).__name__}"
            )

        # Store the constant
        self._symbolic_constants[name] = value

        return SymbolicConstant(name)

    def _collect_predicates(self) -> set[type[Predicate]]:
        """
        Collect all predicates used in the program.

        Returns:
            set[Predicate]: Set of all predicates used in the program.
        """
        predicates = set()

        for element in self._elements:
            predicates.update(element.collect_predicates())

        return predicates

    def render(self) -> str:
        """
        Render the complete ASP program.

        Generates the program text including:
        1. Constant definitions
        2. Program elements (rules, comments, etc.)
        3. Show directives

        Returns:
            str: The complete ASP program.
        """
        # Perform validation
        self._validate_constants()

        # Generate a header
        lines: list[str] = [
            f"% Generated by pyclingo on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        ]

        # 2. Add constant definitions
        used_symbolic_constants = self._collect_used_symbolic_constants()
        if self._symbolic_constants:
            for name, value in self._symbolic_constants.items():
                if name not in used_symbolic_constants:
                    # Only output constants used in the program
                    continue
                if isinstance(value, str):
                    lines.append(
                        f'#const {name} = "{value}".'
                    )  # String values are quoted
                else:
                    lines.append(f"#const {name} = {value}.")  # Integer values are not

        # 3. Add program elements
        lines.extend(element.render() for element in self._elements)

        # 4. Add show directives
        if predicates_to_show := {
            pred for pred in self._collect_predicates() if pred.get_show()
        }:
            lines.append("")

            predicate_signatures = {
                f"{pred.get_name()}/{pred.get_arity()}" for pred in predicates_to_show
            }

            lines.extend(
                f"#show {signature}." for signature in sorted(predicate_signatures)
            )

        # 5. Join everything together
        return "\n".join(lines) + "\n"

    def _collect_used_symbolic_constants(self) -> set[str]:
        """
        Collect all symbolic constant names used in the program.

        Returns:
            set[str]: Set of symbolic constant names used in the program.
        """
        constants = set()

        for element in self._elements:
            constants.update(element.collect_symbolic_constants())

        return constants

    def _validate_constants(self) -> None:
        """
        Validate that all symbolic constants used in the program are registered.

        Raises:
            ValueError: If unregistered constants are found.
        """
        used_constants = self._collect_used_symbolic_constants()

        if unregistered := used_constants - set(self._symbolic_constants.keys()):
            raise ValueError(
                f"Unregistered symbolic constants used in program: {', '.join(sorted(unregistered))}"
            )

    def solve(
        self, models: int = 0, timeout: int = 0
    ) -> Generator[dict[type[Predicate], set[Predicate]], None, None]:
        """
        Solve the ASP program and yield solutions as sets of Predicate objects.

        Args:
            models: Maximum number of models to compute (0 for all)
            timeout: Timeout in seconds (0 for no timeout)

        Yields:
            For each solution, a dictionary mapping Predicate types to sets of Predicate instances

        Raises:
            RuntimeError: If an error occurs during solving

        Notes:
            After all models are yielded, solver statistics are stored in the
            'statistics' attribute of the ASPProgram instance.
        """
        tic = time.perf_counter()

        # Configure and prepare the control object
        control = clingo.Control()
        if models > 0:
            control.configuration.solve.models = models
        if timeout > 0:
            control.configuration.solve.timeout = timeout

        # Get a mapping of predicate names to their types for reconstruction
        predicate_types = {pred.get_name(): pred for pred in self._collect_predicates()}

        # Add and ground the program
        control.add("base", [], self.render())
        control.ground([("base", [])])

        # Solve and yield models
        self.exhausted = False
        self.model_count = 0
        with control.solve(yield_=True) as handle:
            for model in handle:
                self.model_count += 1
                self.satisfiable = True
                yield self._convert_model_to_predicates(model, predicate_types)

            # Save final solve result information
            result = handle.get()
            self.satisfiable = result.satisfiable
            self.exhausted = result.exhausted

        toc = time.perf_counter()

        # Store statistics after solving is complete
        self.statistics = {
            "atoms": int(control.statistics["problem"]["lp"]["atoms"]),
            "rules": int(control.statistics["problem"]["lp"]["rules_tr"]),
            "variables": int(control.statistics["problem"]["generator"]["vars"]),
            "constraints": int(
                control.statistics["problem"]["generator"]["complexity"]
            ),
            "time": toc - tic,
        }

    def _convert_symbol_to_predicate(
        self, symbol, predicate_types: dict[str, type[Predicate]]
    ) -> Predicate:
        """
        Convert a clingo symbol to a Predicate object.

        Args:
            symbol: A clingo Symbol object representing an atom
            predicate_types: Dictionary mapping predicate names to Predicate classes

        Returns:
            A Predicate instance corresponding to the symbol

        Raises:
            ValueError: If the symbol cannot be converted to a predicate
        """
        # Get predicate name
        pred_name = symbol.name

        if pred_name not in predicate_types:
            raise ValueError(f"Unknown predicate type: {pred_name}")

        pred_class = predicate_types[pred_name]
        field_names = [f.name for f in pred_class.argument_fields()]

        # Verify argument count
        if len(symbol.arguments) != len(field_names):
            raise ValueError(
                f"Arity mismatch for predicate {pred_name}: got {len(symbol.arguments)} arguments, expected {len(field_names)}"
            )

        # Convert arguments to appropriate Value objects
        kwargs = {}
        for i, (arg, field_name) in enumerate(zip(symbol.arguments, field_names)):
            # Convert argument based on its type
            if arg.type == clingo.SymbolType.Number:
                kwargs[field_name] = Constant(arg.number)
            elif arg.type == clingo.SymbolType.String:
                kwargs[field_name] = StringConstant(arg.string)
            elif arg.type == clingo.SymbolType.Function:
                # Recursively convert nested predicates
                nested_pred = self._convert_symbol_to_predicate(arg, predicate_types)
                kwargs[field_name] = nested_pred
            else:
                raise ValueError(
                    f"Unsupported symbol type in argument {i} of {pred_name}: {arg.type}"
                )

        # Create and return the predicate instance
        return pred_class(**kwargs)

    def _convert_model_to_predicates(
        self, model, predicate_types: dict[str, type[Predicate]]
    ) -> dict[type[Predicate], set[Predicate]]:
        """
        Convert a clingo model to a dictionary of Predicate objects.

        Args:
            model: A clingo model containing symbols
            predicate_types: Dictionary mapping predicate names to Predicate classes

        Returns:
            Dictionary mapping Predicate types to sets of Predicate instances
        """
        result = defaultdict(set)

        for symbol in model.symbols(shown=True):
            pred_instance = self._convert_symbol_to_predicate(symbol, predicate_types)
            result[pred_instance.name].add(pred_instance)

        return dict(result)
