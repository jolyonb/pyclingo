from __future__ import annotations

from datetime import datetime
from typing import Iterable

from pyclingo.predicate import Predicate
from pyclingo.program_elements import BlankLine, Comment, ProgramElement, Rule
from pyclingo.term import Term
from pyclingo.value import SymbolicConstant


class ASPProgram:
    """
    Represents a complete ASP program.

    This class manages a collection of rules, comments, and other elements
    that make up an ASP program, and provides methods to build and render
    the program.
    """

    def __init__(self) -> None:
        """Initialize an empty ASP program."""
        self._elements: list[ProgramElement] = []
        self._symbolic_constants: dict[str, int | str] = {}

    def fact(self, *predicates: Predicate) -> None:
        """Add one or more unconditional facts to the program."""
        assert all(isinstance(predicate, Predicate) for predicate in predicates)
        for predicate in predicates:
            self._elements.append(Rule(head=predicate))

    def when(self, conditions: Term | list[Term], let: Term) -> None:
        """Create a clingo rule which sets the let term when all conditions are satisfied."""
        condition_list = conditions if isinstance(conditions, list) else [conditions]
        assert all(isinstance(condition, Term) for condition in condition_list)
        assert isinstance(let, Term)
        self._elements.append(Rule(head=let, body=condition_list))

    def forbid(self, *conditions: Term) -> None:
        """Creates a clingo constraint which forbids the specified combination of conditions."""
        assert all(isinstance(condition, Term) for condition in conditions)
        self._elements.append(Rule(body=list(conditions)))

    def comment(self, text: str) -> None:
        """
        Add a comment to the program.

        Args:
            text: The comment text.
        """
        self._elements.append(Comment(text))

    def blank_line(self) -> None:
        """Add a blank line to the program for formatting."""
        self._elements.append(BlankLine())

    def section(self, title: str) -> None:
        """
        Add a section header to the program.

        Args:
            title: The section title.
        """
        self.blank_line()
        self.comment(title)

    def register_symbolic_constant(self, name: str, value: int | str) -> SymbolicConstant:
        """
        Register a symbolic constant with the program.

        Args:
            name: The name of the constant.
            value: The value of the constant (integer or string).

        Raises:
            ValueError: If the name is invalid or already registered.
            TypeError: If the value is not an integer or string.
        """
        # Validate name
        assert isinstance(name, str)
        if not name or not name[0].islower():
            raise ValueError(
                f"Constant name must start with a lowercase letter: {name}"
            )

        if not all(c.isalnum() or c == "_" for c in name):
            raise ValueError(
                f"Constant name can only contain letters, digits, and underscores: {name}"
            )

        # Check for duplicate registration
        if name in self._symbolic_constants:
            raise ValueError(f"Symbolic constant '{name}' is already registered")

        # Validate value type
        if not isinstance(value, (int, str)):
            raise TypeError(
                f"Constant value must be an integer or string, got {type(value).__name__}"
            )

        # Store the constant
        self._symbolic_constants[name] = value

        return SymbolicConstant(name)

    def _collect_predicates(self) -> set[type[Predicate]]:
        """
        Collect all predicates used in the program.

        Returns:
            set[Predicate]: Set of all predicates used in the program.
        """
        predicates = set()

        for element in self._elements:
            predicates.update(element.collect_predicates())

        return predicates

    def render(self) -> str:
        """
        Render the complete ASP program.

        Generates the program text including:
        1. Constant definitions
        2. Program elements (rules, comments, etc.)
        3. Show directives

        Returns:
            str: The complete ASP program.
        """
        # Perform validation
        self._validate_constants()

        # Generate a header
        lines: list[str] = [
            f"% Generated by pyclingo on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        ]

        # 2. Add constant definitions
        used_symbolic_constants = self._collect_used_symbolic_constants()
        if self._symbolic_constants:
            for name, value in self._symbolic_constants.items():
                if name not in used_symbolic_constants:
                    # Only output constants used in the program
                    continue
                if isinstance(value, str):
                    lines.append(
                        f'#const {name} = "{value}".'
                    )  # String values are quoted
                else:
                    lines.append(f"#const {name} = {value}.")  # Integer values are not

        # 3. Add program elements
        lines.extend(element.render() for element in self._elements)

        # 4. Add show directives
        if predicates_to_show := {
            pred for pred in self._collect_predicates() if pred.get_show()
        }:
            lines.append("")

            predicate_signatures = {
                f"{pred.get_name()}/{pred.get_arity()}" for pred in predicates_to_show
            }

            lines.extend(
                f"#show {signature}." for signature in sorted(predicate_signatures)
            )

        # 5. Join everything together
        return "\n".join(lines) + "\n"

    def _collect_used_symbolic_constants(self) -> set[str]:
        """
        Collect all symbolic constant names used in the program.

        Returns:
            set[str]: Set of symbolic constant names used in the program.
        """
        constants = set()

        for element in self._elements:
            constants.update(element.collect_symbolic_constants())

        return constants

    def _validate_constants(self) -> None:
        """
        Validate that all symbolic constants used in the program are registered.

        Raises:
            ValueError: If unregistered constants are found.
        """
        used_constants = self._collect_used_symbolic_constants()

        if unregistered := used_constants - set(self._symbolic_constants.keys()):
            raise ValueError(f"Unregistered symbolic constants used in program: {', '.join(sorted(unregistered))}")
