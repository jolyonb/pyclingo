% Slitherlink puzzle solver by ASPuzzle
% Generated by pyclingo on 2025-05-27 09:43:28

% ===== Grid =====

% Define cells in the grid
cell(R, C) :- R = 1..5, C = 1..5.

% Define outside border cells
outside_grid(cell(R, C)) :- R = (0; 6), C = 0..6.
outside_grid(cell(R, C)) :- C = (0; 6), R = 1..5.
cell(R, C) :- outside_grid(cell(R, C)).

% Define directions in the grid
direction("n", cell(-1, 0)).
direction("ne", cell(-1, 1)).
direction("e", cell(0, 1)).
direction("se", cell(1, 1)).
direction("s", cell(1, 0)).
direction("sw", cell(1, -1)).
direction("w", cell(0, -1)).
direction("nw", cell(-1, -1)).

% Orthogonal directions
orthogonal_directions("n"; "e"; "s"; "w").

% Orthogonal adjacency definition
orthogonal(cell(R, C), cell(R + R_vec, C + C_vec)) :- cell(R, C), orthogonal_directions(D), direction(D, cell(R_vec, C_vec)), cell(R + R_vec, C + C_vec).

% ===== Clues =====

% Grid data
clue(cell(1, 2), 3).
clue(cell(1, 3), 3).
clue(cell(1, 4), 3).
clue(cell(2, 1), 1).
clue(cell(2, 3), 0).
clue(cell(2, 5), 1).
clue(cell(3, 1), 3).
clue(cell(3, 3), 2).
clue(cell(3, 5), 2).
clue(cell(4, 2), 2).
clue(cell(4, 5), 2).
clue(cell(5, 2), 2).

% ===== Symbols =====

% Find anchor cell for inside
min_row_for_inside_anchor(MinR) :- MinR = #min{R : inside(cell(R, C)), R = 1..5}.
inside_anchor(cell(MinR, MinC)) :- min_row_for_inside_anchor(MinR), MinC = #min{C : inside(cell(MinR, C)), C = 1..5}.

% Contiguity for inside
connected_inside(cell(R, C)) :- inside_anchor(cell(R, C)).
connected_inside(C_adj) :- connected_inside(C), inside(C_adj), orthogonal(C, C_adj).
:- inside(C), not connected_inside(C).

% Contiguity for outside
connected_outside(C) :- outside_grid(C).
connected_outside(C_adj) :- connected_outside(C), outside(C_adj), orthogonal(C, C_adj).
:- outside(C), not connected_outside(C).

% Place symbols in the grid
{ inside(cell(R, C)); outside(cell(R, C)) } = 1 :- cell(R, C), not outside_grid(cell(R, C)).

% ===== Rules =====

% Outside border cells must be outside
outside(C) :- outside_grid(C).

% Slitherlink clue constraints
% Efficient handling for 0 clues
:- clue(C, 0), inside(C), not inside(C_adj), orthogonal(C, C_adj).
:- clue(C, 0), outside(C), not outside(C_adj), orthogonal(C, C_adj).
% General handling for 1/2/3 clues
Count = N :- clue(cell(R, C), N), N > 0, inside(cell(R, C)), Count = #count{cell(R_adj, C_adj) : orthogonal(cell(R, C), cell(R_adj, C_adj)), outside(cell(R_adj, C_adj))}.
Count = N :- clue(cell(R, C), N), N > 0, outside(cell(R, C)), Count = #count{cell(R_adj, C_adj) : orthogonal(cell(R, C), cell(R_adj, C_adj)), inside(cell(R_adj, C_adj))}.

% Forbid disconnecting checkerboard pattern for inside
:- inside(cell(R, C)), inside(cell(R + 1, C + 1)), not inside(cell(R, C + 1)), not inside(cell(R + 1, C)), cell(R, C), cell(R + 1, C + 1).
:- inside(cell(R, C + 1)), inside(cell(R + 1, C)), not inside(cell(R, C)), not inside(cell(R + 1, C + 1)), cell(R, C), cell(R + 1, C + 1).

#show.
#show inside/1.
#show outside(cell(R, C)) : outside(cell(R, C)), not outside_grid(cell(R, C)).
