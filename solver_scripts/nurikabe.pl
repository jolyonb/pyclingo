% Nurikabe puzzle solver by ASPuzzle
% Generated by pyclingo on 2025-05-27 09:43:21

% ===== Grid =====

% Define cells in the grid
cell(R, C) :- R = 1..7, C = 1..7.

% Define directions in the grid
direction("n", cell(-1, 0)).
direction("ne", cell(-1, 1)).
direction("e", cell(0, 1)).
direction("se", cell(1, 1)).
direction("s", cell(1, 0)).
direction("sw", cell(1, -1)).
direction("w", cell(0, -1)).
direction("nw", cell(-1, -1)).

% Orthogonal directions
orthogonal_directions("n"; "e"; "s"; "w").

% Orthogonal adjacency definition
orthogonal(cell(R, C), cell(R + R_vec, C + C_vec)) :- cell(R, C), orthogonal_directions(D), direction(D, cell(R_vec, C_vec)), cell(R + R_vec, C + C_vec).

% ===== Clues =====

% Define numbered islands
clue(cell(1, 1), 2).
clue(cell(1, 3), 3).
clue(cell(2, 7), 4).
clue(cell(3, 5), 1).
clue(cell(4, 6), 4).
clue(cell(6, 3), 2).
clue(cell(6, 5), 2).
clue(cell(7, 2), 5).

% ===== Regions =====

% Cell Status Assignment
{ connected(cell(R, C)); regionless(cell(R, C)) } = 1 :- cell(R, C).
anchor(C) :- clue(C, _).
connected(C) :- anchor(C).

% Connection Rules
{ connects_to(C, N) : orthogonal(C, N), not regionless(N) } :- connected(C).
connects_to(N, C) :- connects_to(C, N).

% Region Propagation
region(C, C) :- anchor(C).
region(N, A) :- connects_to(N, C), region(C, A).
connects_to(C, N) :- orthogonal(C, N), region(C, A), region(N, A).

% Integrity Constraints
:- connected(C), not region(C, _).
A1 = A2 :- region(C, A1), region(C, A2).

% Region Size Calculation
region_size(Anchor, Size) :- anchor(Anchor), Size = #count{Cell : region(Cell, Anchor)}.

% Forbid regionless pools

% Regions cannot touch
:- region(C1, A), orthogonal(C1, C2), not region(C2, A), not regionless(C2).

% Find anchor cell for regionless
min_row_for_regionless_anchor(MinR) :- MinR = #min{R : regionless(cell(R, C)), R = 1..7}.
regionless_anchor(cell(MinR, MinC)) :- min_row_for_regionless_anchor(MinR), MinC = #min{C : regionless(cell(MinR, C)), C = 1..7}.

% Contiguity for regionless cells
connected_regionless(cell(R, C)) :- regionless_anchor(cell(R, C)).
connected_regionless(C_adj) :- connected_regionless(C), orthogonal(C, C_adj), regionless(C_adj).
:- regionless(C), not connected_regionless(C).

% ===== Rules =====

% Each island must have the correct size
N = Size :- clue(C, N), region_size(C, Size).

% Size-1 islands must be fully surrounded by stream
regionless(C_adj) :- clue(C, 1), orthogonal(C, C_adj).

% Solution readout
stream(C) :- regionless(C).
island(C) :- region(C, _).

% Forbid 2x2 blocks of regionless
:- regionless(cell(R, C)), regionless(cell(R, C + 1)), regionless(cell(R + 1, C)), regionless(cell(R + 1, C + 1)), cell(R, C), cell(R + 1, C + 1).

#show.
#show island/1.
#show stream/1.
