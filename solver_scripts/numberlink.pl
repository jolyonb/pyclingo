% Numberlink puzzle solver by ASPuzzle
% Generated by pyclingo on 2025-05-27 09:43:14

% ===== Grid =====

% Define cells in the grid
cell(R, C) :- R = 1..9, C = 1..9.

% Define directions in the grid
direction("n", cell(-1, 0)).
direction("ne", cell(-1, 1)).
direction("e", cell(0, 1)).
direction("se", cell(1, 1)).
direction("s", cell(1, 0)).
direction("sw", cell(1, -1)).
direction("w", cell(0, -1)).
direction("nw", cell(-1, -1)).

% Orthogonal directions
orthogonal_directions("n"; "e"; "s"; "w").

% Orthogonal adjacency with direction definition
orthogonal_dir(cell(R, C), D, cell(R + R_vec, C + C_vec)) :- cell(R, C), orthogonal_directions(D), direction(D, cell(R_vec, C_vec)), cell(R + R_vec, C + C_vec).

% Opposite directions
opposite("n", "s").
opposite("ne", "sw").
opposite("e", "w").
opposite("se", "nw").
opposite("s", "n").
opposite("sw", "ne").
opposite("w", "e").
opposite("nw", "se").

% ===== Clues =====

% Define numbered endpoints
symbol(cell(2, 5), 7).
symbol(cell(2, 7), 9).
symbol(cell(2, 8), 4).
symbol(cell(3, 1), 6).
symbol(cell(3, 3), 3).
symbol(cell(4, 4), 8).
symbol(cell(4, 8), 5).
symbol(cell(5, 2), 3).
symbol(cell(5, 4), 6).
symbol(cell(5, 5), 7).
symbol(cell(6, 3), 8).
symbol(cell(7, 1), 2).
symbol(cell(8, 5), 1).
symbol(cell(9, 1), 1).
symbol(cell(9, 2), 2).
symbol(cell(9, 7), 4).
symbol(cell(9, 8), 5).
symbol(cell(9, 9), 9).

% ===== Rules =====

% Identify cells with symbols
has_symbol(Cell) :- symbol(Cell, _).

% Path degree requirements
path_degree(Cell, 1) :- has_symbol(Cell).
path_degree(cell(R, C), 2) :- cell(R, C), not has_symbol(cell(R, C)).

% Path choice constraints
{ path(cell(R, C), D) : orthogonal_dir(cell(R, C), D, _) } = N :- path_degree(cell(R, C), N).

% Bidirectional path constraint
path(Cell2, OppD) :- path(Cell1, D), orthogonal_dir(Cell1, D, Cell2), opposite(D, OppD).

% Symbol propagation
propagated_symbol(Cell, Sym) :- symbol(Cell, Sym).
propagated_symbol(Cell2, Sym) :- propagated_symbol(Cell1, Sym), path(Cell1, D), orthogonal_dir(Cell1, D, Cell2).

% Symbols cannot be connected to different symbols
N = 1 :- symbol(Cell, _), N = #count{Sym : propagated_symbol(Cell, Sym)}.

% Define connected relationship
connected(Cell1, Cell2) :- path(Cell1, D), orthogonal_dir(Cell1, D, Cell2).

% No self-touch constraint
:- orthogonal_dir(Cell1, _, Cell2), propagated_symbol(Cell1, Sym), propagated_symbol(Cell2, Sym), not connected(Cell1, Cell2).

% Solution extraction
cell_directions(cell(R, C), D1, D2) :- cell(R, C), not has_symbol(cell(R, C)), path(cell(R, C), D1), path(cell(R, C), D2), D1 < D2.

#show.
#show cell_directions/3.
